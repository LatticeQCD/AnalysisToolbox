latqcdtools.legacy
=============

```Python
_autoSeed(seed):
'''
We use seed=None to flag the seed should be automatically chosen. The problem is that we need
seed to be an integer when enforcing that different bootstrap samples use different seeds. 
'''
```
```Python
_getBlocksize(ndat, nblocks)
```
```Python
_pseudo(mean, mean_i, numb_blocks)
```
```Python
_pseudo_val(mean, mean_i, numb_blocks)
```
```Python
bootstr(func, data, numb_samples, sample_size=0, same_rand_for_obs=False, conf_axis=1, return_sample=False, seed=None, err_by_dist=False, args=(), nproc=6):
'''
Bootstrap for arbitrary functions. This routine resamples the data and passes them to the function in the same
format as in the input. So the idea is to write a function that computes an observable from a given data set. This
function can be put into this bootstrap routine and will get bootstrap samples as input. Based on the output of the
function, the bootstrap mean and error are computed. The function may return multiple observables that are either
scalars or numpy objects. You can pass a multidimensional object as data, but the bootstrap function has to know
which axis should be resampled which is controlled by conf_axis (default = 0 for one dimensional arrays and
default = 1 for higher order arrays.)

    Parameters
    ----------
    func : callable
        The function that calculates the observable

    data : array_like
        Input data

    numb_samples : integer
        Number of bootstrap samples

    sample_size : integer, optional, default = 0
        Size of sample

    same_rand_for_obs : boolean, optional, default = False
        Use the same random numbers for each observable accessed by index conf_axis - 1. Please note:
            - Objects that are accessed by an axis >= conf_axis + 1 do always have the same random numbers.
            - Objects that are accessed by axis conf_axis < conf_axis - 1 never share the same random numbers.

    conf_axis : integer, optional, default = 0 for dim(data) = 1 or default = 1 for dim(data) >= 2
        Axis that should be resampled

    return_sample : boolean, optional, default = False
        Along with the mean and the error also return the results from the individual samples

    seed: integer, optional, default = None
        seed for the random generator. If None, the default seed from numpy is used (probably from time)

    same_rand_for_obs : boolean, optional, default = False
        same random numbers per observable

    err_by_dist : boolean, optional, default = False
        Compute the error from the distribution using the median and the 68% quantile

    args : array_like or dict, default = ()
        optional arguments to be passed to func. If a dictionary the are passed as **args.

    nproc : integer
        Number of threads to use if you choose to parallelize. nproc=1 turns off parallelization.
'''
```
```Python
bootstr_from_gauss(func, data, data_std_dev, numb_samples, sample_size=1, same_rand_for_obs=False, return_sample=False, seed=None, err_by_dist=True, useCovariance=False, Covariance=None, args=(), nproc=6, asym_err=False):
'''
Same as standard bootstrap routine, but the data are generated by gaussian noise around the mean values in data.
The width of the distribution is controlled by data_std_dev. Note, that the function has to average over samples.
This means that data_std_dev should always be the standard deviation of a single measurement and not the standard
deviation of a mean.
'''
```
```Python
dev_by_dist(data, *args, **kwargs)
```
```Python
jackknife(func, data, numb_blocks=20, conf_axis=1, return_sample=False, args=(), nproc=6):
'''
Jackknife routine for arbitrary functions. This routine creates the jackknife like blocked subsets of data and
passes them to the function in the same format as in the input data. So the idea is to write a function that
computes an observable from a given data set. This function can be put into this jackkife routine and will get the
jackknifed blocked data as input. Based on the output of the function, the jackkife mean and error are computed.
The function may return multiple observables that are either scalars or numpy objects. You can pass a
multidimensional object as data, but the jackknife function has to know from which axis blocks should be removed.
This is controlled by conf_axis (default = 0 for one dimensional arrays and default = 1 for higher order arrays).
Look into the __init__ function of the nimbleJack class to see in detail how this is implemented.

    Parameters
    ----------
    func : callable
        The function that calculates the observable

    data : array_like
        Input data

    numb_blocks : integer
        Number of jackknife blocks

    conf_axis : integer, optional, default = 0 for dim(data) = 1 and default = 1 for dim(data) >= 2
        Axis that should be resampled.

    return_sample : boolean, optional, default = False                                           
        Along with the mean and the error also return the results from the individual samples

    args : array_like or dict, default = ()
        optional arguments to be passed to func. If a dictionary they are passed as **args.

    nproc : integer
        Number of threads to use if you choose to parallelize. nproc=1 turns off parallelization.
'''
```
```Python
recurs_append(data, sample_data, axis, conf_axis, sample_size, same_rand_for_obs, i, my_seed):
'''
Recursive function to fill the sample. 
'''
```
```Python
reduce_tuple(func)
```
```Python
std_dev(data, *args, **kwargs)
```
```Python
std_err(data, *args, **kwargs)
```
```Python
std_mean(data, *args, **kwargs)
```
```Python
std_median(data, *args, **kwargs)
```
```Python
std_var(data, *args, **kwargs)
```
```Python
class nimbleBoot(func, data, numb_samples, sample_size, same_rand_for_obs, conf_axis, return_sample, seed, err_by_dist, args, nproc):
```
```Python
class nimbleGaussianBoot(func, data, data_std_dev, numb_samples, sample_size, same_rand_for_obs, return_sample, seed, err_by_dist, useCovariance, Covariance, args, nproc, asym_err):
```
```Python
class nimbleJack(func, data, nblocks, confAxis, return_sample, args, nproc):
'''
Class allowing for parallelization of the jackknife function. 
'''
```
